# 10장. 실시간 게임 순위표

### 1단계 : 문제이해 및 설계범위 확정
- 기능 요구사항
  - 상위 10명의 플레이어 표시
  - 특정 사용자의 순위 표시
  - 어떤 사용자보다 n순위 위와 아래에 있는 사용자 표시
- 비기능 요구사항
  - 점수 업데이트는 실시간으로
  - 일반적인 확장성, 가용성, 안정성

### 2단계 : 개략적 설계안 제시 및 동의 구하기
- API 설계
 - 순위 갱신 : POST /v1/scores (user_id, points)
 - 순위표에서 상위 10명의 플레이어 : GET /v1/scroes
 - 특정 사용자의 순위 : GET /v1/scores/{:user_id}
- `게임 서비스` 와 `순위표 서비스` 로 나눔
  - `게임 서비스`는 승리의 유효성을 판단하여 `순위표 서비스`에 점수 갱신 요청
  - `순위표 서비스`는 DB 점수 갱신
- 클라이언트가 `순위표 서비스`직접 통신하면? : 어뷰징 문제
- 두 서비스 사이에 큐가 필요한가? : 다른 서비스가 필요하다면 필요
- 데이터 모델
  - 관계형 데이터 베이스
    - 간단하지만 성능이 안나옴
    - 특정 사용자의 순위를 알기엔 전체를 조회해야함
    - 특정 사용자 위아래의 사용자를 찾기 어려움
  - 레디스
    - sortedset : 해시테이블과 스킵리스트 활용
      > 스킵리스트 : http://redisgate.kr/redis/configuration/internal_skiplist.php
    - commend
      - ZADD : 추가
      - ZINCRBY : 점수 증가
      - ZRANGE / ZREVERANGE : 범위 조회
      - ZRANK / ZREVERANK : 특정 사용자의 위치
    - 활용
      - 사용자가 점수를 획득한 경우
      - 사용자가 순위표 상위 10명을 조회하는 경우
      - 사용자가 자기 순위를 조회하는 경우
      - 특정 사용자 순위를 기준으로 일정 범위 내 사용자를 질의하는 경우
  - 데이터의 영속성에 문제가 있을 수 있으나 읽기 사본을 만들어서 해결
  - 가장 자주 검색되는 상위 10명의 사용자 정보를 캐시하여 성능 최적화

### 3단계 : 상세 설계
- 자체 서비스 vs 클라우드 서비스
  - 로드밸런서 == api gateway
  - 웹서버 == 클라우드의 람다 : 서버리스 (트래픽에 따라 자동 규모 확장)
- 레디스 규모 확장
  - 고정 파티션 : 고르게 분포되면 좋음
  - 해시 파티션
    - 레디스 클러스터에서는 해시 슬롯을 제공
    - 상위 10명 : 분산-수집 접근법을 활용
- 대안 : NoSQL
  - 쓰기 연산에 최적화
  - 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬
  - 적당한 전역 보조 색인 (파티션키, 정렬키) 를 활용
### 4단계 : 마무리
  - 순위표에 표시할 사용자 ID와 사용자 객체 사이에 대응관계 저장 : 더 빠르게 사용자 정보 확인
  - 동점자 : 타임스탬프값이 오래된 사용자 순위가 높다고...
  - 시스템 장애 복구
    - 타임스탬프와 함께 기록
    - 레코드당 한번씩 zincrby 호출하여 순위표 복구
