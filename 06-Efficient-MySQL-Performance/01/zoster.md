# Chpater 1. Query response time
* "성능은 곧 쿼리 응답 시간이다"
* MySQL을 관리하는 입장이 아니라 사용하는 입장이며, 최소한의 노력으로 최대한의 성과가 필요한 사람이라고 가정한다
* 쿼리 응답 시간은 MySQL이 쿼리를 실행하는 데 소요되는 시간이다
## 1-1 A True Story of False Performance
* 하드웨어에 집중하면 안된다
* 중요한 인덱스가 없는 단일 쿼리를 발견해 인덱싱하자 성능이 획기적으로 향상된 적이 있다
* 그리고 이것은 수십년간 반복되는 문제기도 하다

## 1-2 North Star
* 쿼리 응답 시간은 실제 해결책으로 이어지는 강력한 특성이 있으므로 가장 먼저 살펴봐야 한다
### 의미 있는 것
* 쿼리 응답 시간은 누구나 관심을 가지는 유일한 메트릭이다
### 실행 가능한 것
* 결국 MySQL 성능에서 핵심 지표인 쿼리 응답 시간 향상에 집중해야 한다
* 하드웨어 문제로 돌려선 안된다
## 1-3 Query reporting
* 쿼리 메트릭은 응답 시간, Lock time, 조회된 행 등 쿼리 실행에 관한 중요한 정보를 제공한다
* 그러나 다른 메트릭과 마찬가지로 원시 값이기 때문에 이것을 보고서로 변환해야 하는데 Query reporting으로 볼 수 있다
* 그러나 이 역시 목적을 달성하기 위한 수단이다
* MySQL 성능을 높이려면 쿼리를 최적화해야 하고, 그러기 위해선 쿼리 실행 방식을 이해해야 한다
* 그러기 위해선 Query report와 metadata등 관련 정보를 사용해 분석해야 한다

### Sources
* 쿼리 메트릭은 Slow query log / performance schema에서 나온다
* slow query log는 디스크에 있는 로그이고 performance schema는 database이다
* performance schema가 가장 좋은 소스이다, 모든 메트릭을 제공하면서 가장 일관성이 있기 때문
* slow query는 기본 비활성이지만 켜도 MySQL 재시작은 필요 없다
* performance schema는 기본 활성이지만 꺼져있는 경우 켜기 위해 MySQL 재시작이 필요하다
### Aggregation
* 쿼리 메트릭은 쿼리별로 그룹화되고 집계된다
* 집계하기 위한 고유 식별자는 Query를 정규화하고(Select 'col' FROM 'tbl' WHERE 'id'=?) 해싱하여 고유한지 여부를 체크한다
  * WHERE 절을 동적으로 추가하는 경우 시스템에서 같은 쿼리로 인식하더라도 MySQL에서는 다른 쿼리가 된다
  * Parameter만 동적으로 변경하는 경우 같은 쿼리로 인식된다

### Reporting
* 쿼리 프로파일에는 느린 쿼리가 표시된다, 느림의 기준은 일반적으로 쿼리 시간이 기본 정렬이다
* 쿼리 총시간 : 쿼리들이 실행된 전체 시간, 1초짜리 쿼리 100번 실행되면 100초
* 실행 시간 비율 : 쿼리 총시간을 실행 총시간으로 나눈 값, 300초 동안 쿼리가 실행되었고 A의 쿼리 총시간이 100초이면 33%
* 쿼리 부하 : 쿼리 총시간을 클럭 타임으로 나눈것, 일반적으로 1.0보다 작으면 동시에 실행되지 않는 쿼리, 1보다 크면 쿼리가 동시성을 가진다는 의미
* 쿼리 보고서는 하나의 쿼리에 대한 모든 것을 보여준다
  

## 1-4 Query Analysis
* 쿼리 분석의 목표는 느린 응답 시간을 해결하려는 것이 아니라, 쿼리 실행을 이해하려는 것, 해결은 최적화에서
### Query Metrics(9)
1. Query time
   * 가장 중요한 메트릭, query time에는 lock time이 포함됨
   * Transaction - Statement - Stages - Waits 계층 구조로 구성 됨
2. Lock time
   * 쿼리를 실행하는 동안 lock을 획득하여 사용한 시간
   * 아주 잘 최적화된 데이터베이스에서 가장 느린 쿼리를 기준으로 4~50%를 lock으로 사용한다(저자)
   * Table Locks : 테이블 전체에 Lock을 거는 방식으로, MyISAM 같은 스토리지 엔진에서 주로 사용
   * Row Locks: InnoDB와 같은 스토리지 엔진에서 특정 행에 대해서만 Lock을 거는 방식. 더 세밀한 Lock으로 동시성을 높일 수 있다
   * Lock time이 길어지는 주요 원인은 다음과 같다
     * Contention: 여러 트랜잭션이 동일한 데이터에 접근하려 할 때 발생. 이로 인해 하나의 트랜잭션이 완료될 때까지 다른 트랜잭션이 대기해야 할 수 있다
     * Lock Granularity: 테이블 Lock은 행 Lock보다 더 많은 경합을 유발할 수 있다. 가능하다면 행 Lock을 사용하는 것이 성능 향상에 유리하다
   * Lock은 주로 쓰기에 사용되며 row lock은 concurrency에 따라 달라진다
   * 읽기에는 nonlocking/locking reads가 있다
     * nonlocking이더라도 shared metadata lock을 획득해야 하므로 lock time이 0은 아니다
     * alter table과 같은 metadata lock 작업은 nonlocking read를 느리게 만들 수 있다
3. Rows examined
   * 조건 절에 일치하는 행을 찾기 위해 접근한 행의 수
   * selectivity가 높을수록 낭비가 적은 쿼리라고 할 수 있다
4. Rows sent
   * 클라이언트에 반환된 행의 수
   * Rows examined = sent
     * 일반적으로 유사할 수록 좋지만 10,000개 행이 있는 테이블에서 1,000개 행을 항상 조회하고 보낸다면 테이블 스캔을 유발한다는 의미
   * Rows examined > sent
     * query나 index의 selectivity가 좋지 않다는 신호
   * Rows examined < sent
     * 가능은 하지만 잘 없음, 잘못된 쿼리일 가능성은 높아보임
5. Rows affected
   * 의도한 행보다 더 많은 행이 영향을 받으면 문제가 있음
6. Select scan
   * 이 값이 0이 아니라면 쿼리 최적화를 강력하게 권장한다 
7. Select full join
   * 항상 0이어야 한다, 아니라면 쿼리 최적화를 해야 한다
8. Created tmp disk tables
   * 디스크에 생성된 임시 테이블의 수는 쿼리 실행 중 메모리 용량을 초과하여 디스크에 임시 테이블을 생성해야 할 때 측정된다. 
   * 일반적으로 쿼리의 성능 저하를 나타내며, 메모리 최적화나 쿼리 수정을 통해 개선할 수 있다
9. Query count 
   * 쿼리 수행 횟수는 특정 쿼리가 얼마나 자주 실행되는지를 나타내는 메트릭
   * 데이터베이스의 부하를 분석하고, 자주 실행되는 쿼리를 최적화하는 데 중요한 정보를 제공한다
### Metadata and the Application
* 메타데이터는 데이터베이스 객체에 대한 데이터를 의미
  * 테이블 구조, 인덱스, 데이터 유형, 저장 프로시저 등 데이터베이스 스키마의 모든 요소를 포함한다
  * EXPLAIN : 쿼리 실행 계획을 제공하며, MySQL이 쿼리를 어떻게 실행할지 그리고 어떤 인덱스가 사용될지 보여준다
  * SHOW CREATE TABLE: 테이블의 구조를 보여주며, 각 열의 데이터 유형, 인덱스 및 기타 제약조건 정보를 제공
* 데이터베이스와 상호작용하는 애플리케이션의 컨텍스트를 이해하는 것은 쿼리 최적화에 중요하다.
* 쿼리는 애플리케이션의 요구 사항을 충족시키기 위해 작성되기 때문
### Relative Values
* 쿼리 메트릭은 절대적인 기준이 아니며 쿼리와 애플리케이션의 특정 상황에 따라 상대적으로 평가되어야 한다
### Average, Percentile, and Maximum
* 평균은 지나치게 낙관적이며, 백분위는 추정, 최대는 가장 좋은 대표 지표이다
* Average
  * 평균은 모든 쿼리 응답 시간을 합산한 뒤 쿼리 수로 나눈 값이다
  * 일반적인 쿼리 성능을 가늠할 수 있는 지표이지만, 극단적인 값에 의해 왜곡될 수 있음
* Percentile
  * 백분위는 쿼리 응답 시간을 순서대로 나열했을 때 특정 백분율에 해당하는 값을 찾는 방법이다
  * 95번째 백분위(P95)는 전체 쿼리 중 95%가 이 시간 이하로 완료됨을 의미한다
  * 가장 바람직한 백분위수는 P999(99.9%)
* Maximum
  * 백분위가 갖는 문제를 보완
  * 시스템의 잠재적 성능 문제를 드러내는 데 유용하며, 최악의 경우를 이해하는 데 중요하다
## 1-5 Improving Query Response Time
* 최종 목적지는 더 빠른 쿼리 응답 시간이다
### Direct Query Optimization
* 쿼리 구조 재검토: SQL 쿼리가 효율적으로 작성되었는지 검토하고, 필요한 경우 조인 순서, 필터 조건, 사용된 인덱스 등을 최적화한다
* 인덱스 최적화: 적절한 인덱스가 존재하는지 확인하고, 필요에 따라 새로운 인덱스를 추가하거나 사용되지 않는 인덱스를 제거하여 쿼리 성능을 향상시킨다
### Indirect Query Optimization 
* 데이터 모델링 변경: 데이터 스키마를 조정하거나 데이터 분할(샤딩)과 같은 전략을 적용하여 데이터 관리를 최적화한다
* 접근 패턴 조정: 애플리케이션의 데이터 접근 방식을 분석하고, 필요에 따라 캐싱 전략을 도입하거나 데이터 읽기/쓰기 패턴을 조정한다
## 1-6 When to Optimize Queries
* 느린 쿼리를 수정하는 시간을 투자하는 게 항상 효율적인 건 아니기 때문에 매번 쿼리를 최적화해서는 안된다
* 엔지니어링 리소스 역시 비즈니스 관점에서 접근해야 한다
### 성능이 고객에게 영향을 미칠 때
* 엔지니어의 의무이다
* 사후 대응이므로 좋지 않은 방법이라고 말할 수도 있지만 대개 고객이 신고하기 전까지 엔지니어는 쿼리 메트릭을 확인하지 않는다
* 최적화를 언제든지 실행할 준비를 해두는 것이 중요하다
### 코드 변경 저후
* 쿼리와 관계없는 변화라고 할지라도 접근 패턴의 변경에 따라 쿼리가 느려질 수 있다
### 한 달에 한 번
* 코드와 쿼리가 변경되지 않더라도 데이터와 접근 패턴이 변경될 수 있다
* MySQL은 초고속으로 성장하는 애플리케이션도 안정적으로 확장할 수 있다
* 한 달에 한 번 쿼리 메트릭을 검토하면 이상적인 엔지니어를 넘어 전설로 부상할 수 있을 것이다
## 1-7 MySQL: Go Faster
* 쿼리나 애플리케이션 변경 없이 MySQL을 더 빠르게 만드는 비밀은 없다
* MySQL의 속도를 높이려면 직접 및 간접 쿼리 최적화라는 여정을 시작해야 한다