# 6. 서버메트릭
- 메트릭의 목적은 시스템이 어떻게 작동하는지 측정하고 보고 -> MySQL 메트릭도 성능과 밀접 관련
- 메트릭을 하나만 분리해서 생각하지 말고 전체적으로 확인해서 분석해야함
- MySQL 메트릭이 방대하고 체계적이지 않으므로 매우 유용하지만, 효과적으로 배우려면 집중과 조직화가 필요
## 6.1 쿼리 성능 대 서버 성능
- MySQL 성능에는 `쿼리 성능`과 `서버 성능`이라는 2가지 측면 존재
  - 5장에서는 워크로드를 최적화하여 쿼리 성능을 다룸
##### 동시성과 경합
- `동시성`은 쿼리 성능을 떨어뜨리는 `경합`으로 이어짐
  - 단독으로 실행되는 쿼리는 다른 쿼리와 함께 실행될 때, 다른 성능을 냄
  - 범용 확장성 법칙에서 경합은 나누는 수에 있으며, 부하 증가에 따라 처리량이 감소함을 의미함 -> 동시성과 경합은 피할 수 없음
- 서버 성능 분석은 모든 쿼리가(동시성) 공유되고, 시스템 리소스(경합)을 놓고 경쟁할때 워크로드를 처리하는 방식을 확인하는데 유용
  - 특정 워크로드는 경합이 거의 없는데, 다른 워크로드는 쿼리와 서버 성능을 떨어뜨림
- 서버 성능을 분석하면 워크로드의 쿼리가 함께 작동하는 정보를 알수 있음
##### 튜닝
- 서버 성능에는 전적으로 워크로드 때문은 아님
  - MySQL, 운영체제, 하드웨어 등 3가지 추가 요소 존재
- 쿼리 성능에서는 3가지 요소가 워크로드에 적합하게 구성되어 있다고 가정함
  - 3가지 요소의 결함은 워크로드 보다 훨씬 적은 영향을 미침
- MySQL은 튜닝이 필요 없음 -> 효과 미미
- 그러나 튜닝을 해야한다면 알려진 안정적인 워크로드로 서버 성능을 분석해야함 
  - 그렇지 않으면 성능 향상이 튜닝의 결과라고 확신할 수 없음
##### 성능 회귀
- 일반적으로 쿼리 성능, MySQL 튜닝, 하드웨어 결함이 아니면 최후 수단으로 성능 회귀(또는 버그)를 의심함
- 다른 분들이 이러한 성능 저하를 밝히고자 성능 분석하는 좋은 예가 있음 -> 여러 레퍼런스로 인해 버그 확인은 쉽게 확인 가능
## 6.2 정상과 안정
##### 정상
- 모든 것이 제대로 작동하는 평상 시 애플리케이션에 대해 MySQL이 보이는 모든 성능
  - 성능의 일부 측면이 평소보다 더 높거나 낮은지, 더 빠르거나 느린지 등을 결정하는 기준선
- `Threads_running`이 50 미만이면 정상
  - 현재 CPU 코어가 48개 미만이고, MySQL 성능이 실행 중인 64개 스레드 이상으로 확장하지 않는다면 안정적인 값은 50 미만
  - 애플리케이션에서 60개 스레드 실행이 정상이고 안정적이라면 이는 엄청난 성능
##### 안정
- 더 나은 성능을 추구하는 과정에서 안정적인 성능을 놓쳐서는 안됨
  - MySQL에서 최대 성능을 짜내는 것이 목표가 아닌 안정적인게 중요
  - 한계에서 성능이 불안정해지면 성능보다 더 큰 문제 발생
- 안전성은 성능을 제한하는 것이 아닌 모든 수준에서 지속 가능한 성능을 보장
## 6.3 핵심 성능 지표
##### 응답 시간
- 모두가 관심을 두는 유일한 지표 -> 응답시간이 빠르더라도 KPI도 함께 고려해야함
  - 응답시간이 빠르더라도 모든 쿼리가 오류율 100%면 의미 없음
- 정상이고 안정적이면서 응답시간이 낮을수록 좋음
##### 오류
- 오류의 비율 -> 쿼리 오류뿐만 아니라 쿼리, 연결, 클라이언트, 서버와 같은 모든 유로
- 정상이고 안정적인 오류울이 목표이며, 0에 가까울수록 좋음
##### QPS
- QPS는 성능을 나타내지만 그 자체가 성능은 아님
  - 비정상적으로 높은 QPS는 문제일수 있음
- 정상이고 안정적인 QPS이며 목푯값은 그때마다 다름
##### 실행 중인 스레드
- MySQL이 QPS를 달성하기 위해 얼마나 노력하는지를 측정
- 하나의 스레드는 하나의 쿼리를 실행하기에, QPS와 스레드는 밀접하여 같이 고려해야함
- 정상이고 안정적인 스레드 실행, 즉 낮을수록 좋음


- 4가지 메트릭이 MySQL의 핵심 성능 지표임 -> 항상 모니터링 필요
## 6.4 메트릭 필드
- 메트릭 필드 -> 모든 메트릭은 6개의 클래스 가운데 하나에 속함<br>
![img.png](img.png)
- 하나의 메트릭이 아닌 다양한 메트릭을 통해 분석 필요
##### 응답 시간 메트릭
- MySQL이 응답하는 데 걸리는 시간을 나타냄
- 하위 수준의 세부사항을 포함하므로 메트릭 필드에서 최상위 수준
- 쿼리 응답 시간은 가장 중요하고 일반적으로 모니터링되는 유일한 지표
- MySQL은 단계별 명령문을 실행하고 시간을 지정할 수 있음
  - UPDATE문은 15단계 중 1단계에 불과함, 실제 쿼리 실행은 여러 단계 중 하나
  - 단계별 응답 시간은 MySQL 전문가가 서버 성능 문제를 심층 조사하는데 사용됨
- 응답 시간 메트릭은 중요하지만 완전히 불투명함
##### 속도 메트릭
- MySQL이 개별 작업을 얼마나 빨리 완료하였는 지를 나타냄
  - QPS는 보편적인 데이터베이스의 속도 메트릭
- 속도가 증가하면 관련 사용률을 높일 수 있음
- 속도와 사용률의 관계는 다른 변경 사항을 가정하지 않음
  - 사용률이나 사용률에 영향을 미치는 속도를 변경할 때에만 사용률을 높이지 않고 속도를 높일수 있음
  - 속도가 관계의 원인이므로 사용률보다 속도를 변경하는 것은 쉬움
##### 사용률 메트릭
- MySQL이 유한한 리소스를 얼마나 많이 사용하는지를 나타냄
  - CPU 사용량, 메모리 사용량, 디스크 사용량 등 -> 컴퓨터는 유한한 기계임
- 제한 속도를 사용률오 표현할 수 있음
  - 속도는 최대 속도가 있을 때 제한됨
- 사용률이 높아지면 관련 속도가 낮아질 수 있음
  - 악성 쿼리는 디스크 I/O 사용률을 100%를 만들고 QPS는 급격히 떨어짐
  - 사용률이 방성직에 나누는 수의 있는 경합과 일관성을 높임
- 사용률이 100%에 가까워지면? MySQL은 대기함
  - 그림을 보면 쿼리 실행이 대기했다가 재시작하므로 화살표가 `지연`으로 되어 있음
- 지연은 불안정하지만 2가지 이유로 피할 수 있음(`책에는 없으므로 되어 있는데 오타로 보임`)
  - 부하를 줄이거나 하드웨어 용량을 늘려 개선할 수 있음 
  - 해결하기 어렵지만 불가능하지 않음
    - 회전 디스크(HDD)를 사용하는 경우라면 NVMe로 업그레이드
##### 대기 메트릭
- 쿼리 실행 중 유후 시간을 나타냄
  - 경합과 일관성으로 쿼리 실행이 지연되는 대기가 발생
- 대기 메트릭은 속도나 응답 시간(메트릭에 따라 다름)으로 계산하지만, MySQL이 작동하지 않을 때를 나타내므로 별도로 분류할 가치가 있음
  - 성능과 상반됨
  - 그림에서 어둡게 표시한 이유는 작동하지 않기 때문
- 대기를 피할 수 없음 -> 목표는 대기를 없애는게 아니고 줄이는 것
- MySQL이 너무 오래기다리면 대기-오류 관계인 시간 초과가 발생
- 타임 아웃 관련 시스템 변수는 존재 -> 설정을 사용하되 의존해서는 안됨
  - `lock_wait_timeout` 기본값은 365일 -> 애플리케이션 코드 레벨에서 시간 초과를 사용하여 방지
##### 오류 메트릭
- 오류를 나타냄
  - 대기 시간 초과는 오류의 한 유형
- 비정상적인 오류는 좋지 않음
##### 접근 패턴 메트릭
- 애플리케이션이 어떻게 MySQL을 사용하는지를 나타냄
  - SQL문의 각 유형(`Com_select`, `Com_insert` 등)에 대한 메트릭 존재
- 접근 패턴 메트릭은 더 높은 수준의 메트릭 아래에 있음
  - `Com_select`은 실행된 `SELECT`문의 수를 계산함 -> 속도(QPS) 또는 사용률(%)을 나타낼 수 있음
##### 내부 메트릭
- 해당 책에서는 다루지 않음 -> MySQL을 더 자세히 알고 싶을때를 대비해 충분히 알면 됨
## 6.5 스펙트라
##### 쿼리 응답 시간
- 4가지 핵심 성능 지표 중 하나 -> MySQL 8.0 이전에는 해당 메트릭 미존재
- 성능 스키마에서 밀리초 단위로 전역 쿼리 응답시간을 얻을 수 있음
````
SELECT 
  ROUND(bucket_quantile * 100, 1) AS p,
  ROUND(BUCKET_TIMER_HIGH / 1000000000, 3) AS ms
FROM
  performance_schema.events_statements_histogram_global
WHERE
  bucket_quantile >= 0.95
ORDER BY bucket_quantile LIMIT 1;
````
- 화자는 p999를 선호
##### 오류
- 4가지 핵심 성능 지표 중 하나 -> MySQL 8.0 부터는 성능 스키마에서 모든 오류 수를 쉽게 얻을 수 있음
````
전역 오류수

SELECT 
  SUM(SUM_ERROR_RAISED) AS global_errors
FROM
  performance_schema.events_errors_summary_global_by_error
WHERE
  ERROR_NUMBER NOT IN (1287);
````
- MySQL에는 오류와 경고가 너무 많아서 전역 오류율이 얼마나 될지 알수 없음
  - 불가능한 오류율 0을 기대하거나 달성하려하지 말자
- 목표는 애플리케이션의 일반 오류율을 정립하는 것
- 클라이언트 오류 메트릭
  - `Abored_clients`
  - `Abored_connects`
  - `Connection_errors_%`
- MySQL에 연결하지 못한 클라이언트는 MySQL은 연결 오류를 보고 하지 않음
##### 쿼리
- MySQL이 얼마나 빨리 작동하고 어떤 유형의 작업을 수행하고 있는지 매우 높은 수준에서 보여줌
- QPS
  - 4가지 핵심 지표 중 하나
  - `Queries`는 매트릭 카운터이지만 QPS는 두 `Queries`측정치의 차이를 초 단위로 측정 시간의 차이를 나눈 값
  - 전반적으로 MySQL 처리량을 나타내므로 많은 관심을 두지만, 이것만 의존하면 안됨
  - QPS는 애플리케이션 사용량에 따라 변동
  - 비정상적인 QPS 변화는 의심스럽고 조사할 가치가 있음
  - `Quesions`는 클라이언트가 보낸 쿼리만 계산
- TPS
  - TPS는 QPS만큼 중요
  - 명시적 트랜잭션 처리량 3가지 메트릭
    - `Com_begin`
    - `Com_commit`
    - `Com_rollback`
  - `Com_begin`과 `Com_commit`의 비율은 거의 비슷 -> 트랜잭션 지연문제가 발생하면 `Com_begin` 비율이 높음
  - TPS는 `Com_commit`을 사용하여 측정
##### 읽기/쓰기
- 9개의 읽기/쓰기 메트릭 존재
  - `Com_select`
  - `Com_delete`
  - `Com_delete_multi`
  - `Com_insert`
  - `Com_insert_select`
  - `Com_replace`
  - `Com_replace_select`
  - `Com_update`
  - `Com_update_multi`
- `Com_select`는 select 문 수를 세는 카운터
- `Com_delete_multi`와 `Com_update_multi` 의 접미사 `multi`는 다중 테이블 참조
  - 다중 테이블 delete는 `Com_delete_multi`만 증가, 단일 delete는 `Com_delete` 증가
- 읽기/쓰기 메트릭은 `Queries`를 구성하는 쿼리의 중요한 유형과 처리량을 나타냄 -> 성능과 관련하여 가장 중요한 메트릭
##### 관리
- 데이터베이스 관리자만 사용할 수 있는 명령어를 이용하여 메트릭으로 보는 것
  - `Com_flush`
  - `Com_kill`
  - `Com_purge`
  - `Com_admin_commands`
- 위에 세가지 메트릭은 flush, kill, purge 구문을 참조
- `Com_admin_commands`는 `Com_`상태 변수가 없는 다른 관리 명령어 참조
  - `ping`과 같은 명렁어
##### SHOW
- 40개가 넘는 show 구문이 있으면 상당수가 `Com_show_` 메트릭에 해당
  - `Com_show_databases`
  - `Com_show_errors`
- 해당 쿼리들은 MySQL에서 스레드, 시간과 리소스 사용 -> Show 명령도 중단 가능
##### 스레드와 연결
- 4가지 핵심 성능 지표 중 하나
  - 활성 쿼리 실행과 직접 연결
  - MySQL이 얼마나 열심히 일하는지를 알려주며 CPU 코어 개수를 이를 효과적을 ㅗ제어함
- 스레드 연결에 대한 가장 중요한 4가지 메트릭
  - Connections
  - Max_used_connections
  - Threads_connected
  - Threads_running
- `Connections`은 성공과 실패를 포함한 MySQL에 대한 연결 시도 횟수
- `Max_used_connections`는 연결 사용률
- `Threads_connected` 클라이언트가 연결되거나 끊어지면 해당 게이지 메트릭이 늘거나 줄여짐
- `Threads_running` 게이지 메트릭이며 CPU 코어 수의 약 두 배 수준인 훨씬 낮은 값에서 급격하게 떨어짐
- 몇개의 스레드만으로 높은 처리량(QPS) 달성이 가능 -> 애플리케이션 워크로드에 영향을 받음
##### 임시 개체
- MySQL이 행 정렬, 대규모 조인 등 다양한 목적으로 사용하는 임시 파일과 테이블
  - `Created_tmp_disk_tables`
  - `Created_tmp_tables`
  - `Created_tmp_files`
- 임시 개체는 생성되는 비율이 안정적이면 해롭지 않음
- 가장 영향력 있는 메트릭은 `Created_tmp_disk_tables`, 이는 `Created_tmp_tables`와 상호 관계가 있음
  - 임시 테이블이 필요하면 메모리 임시 테이블로 시작하여 `Created_tmp_tables` 증가
  - 일정 사이즈 보다 커지면 임시 테이블을 디스크에 써서 `Created_tmp_disk_tables` 증가
  - 디스크에 쓰면 I/O속도가 느리기 때문에 성능에 도움이 안됨
##### 준비된 명령어
- 준비된 명령어는 양날검 -> 적절히 사용하면 효율성이 높아지지만 반대면 리소스 낭비
- 2가지 메트릭으로 카운트됨
  - `Com_stmt_prepare`
  - `Com_stmt_execute`
- `Com_stmt_execute`가 `Com_stmt_prepare`보다 훨씬 커야함 -> 1:1 비율이면 낭비
##### 잘못된 SELECT
- 4가지 메트릭은 성능에 좋지 않은 `SELECT`문의 발생을 카운트함
  - Select_scan
  - Select_full_join
  - Select_full_range_join
  - Select_range_check
- `Select_full_join` 보다 `Select_full_range_join`이 더 나음
- `Select_range_check`는 `Select_full_range_join`과 비슷하지만 더 나쁨
- 잘못된 `Select`메트릭은 실질적으로 0이어야함
  - 일부 쿼리가 `Select_scan`이나 `Select_full_range_join` 불가피할 수 있지만, 나머지는 0이어야함
##### 복제
- 복제 지연은 골칫거리를 만듬 -> 지연은 1초 미만이여야함
- 복제 지연에 악명 높은 메트릭 `Seconds_Behind_Source` -> 0과 높은 값 사이에 이동하는데 혼란스러움
  - pt-heartbeat와 같은 도구를 통해 실제 복지 지연 측정 필요
##### 데이터 크기
- 데이터 베이스 크기가 커지는 걸 모니터링 필요 -> 데이터가 적을수록 성능이 향상됨
- MySQL 정보 스키마 테이블(information_schema.tables)에서 테이블 크기 제공
- 데이터베이스와 테이블 크기 메트릭에는 표준은 없음
  - 15분 마다 체크하는게 좋음
##### InnoDB
- MySQL 기본 스토리지 엔진이므로 잘 다룰 수 있도록 스스로 단련해야함
##### 변경 내역 목록 길이(HLL)
- InnoDB에서 변경된 데이터를 기록하는 목록의 길이를 나타내며, 몇시간 동안 증가하면 이전 행 버전을 제거하지 않고 유지됨을 나타냄 -> 장시간 트랜잭션이 커밋되지 않거나 클라이언트 연결 이슈등 발생
- `innodb.trx_rseg_history_len`을 통해 드러남, 1,000 미만 이 정상
- 성능에 직접적으로 영향을 미치지 않지만, 문제의 전조이므로 무시하면 안됨
##### 교착 상태
- 두 개 이상의 트랜잭션이 서로의 자원을 기다리며 무한 대기 상태에 빠지는 상황을 말함
- 교착 상태가 발생하면 트랜잭션이 더 이상 진행되지 않으므로, 성능에 심각한 영향을 미칠 수 있음
- `innodb.lock_deadlocks`를 통해 메트릭 값을 늘림
- 이를 방지하기 위해 트랜잭션이 자원을 요청하는 순서를 일관되게 유지하거나, MySQL의 교착 상태 감지 기능을 활용할 수 있음
##### 행 잠금
- 행 잠금은 트랜잭션이 특정 행에 대한 독점적 접근을 요구할 때 발생하며, 다른 트랜잭션이 해당 행에 접근하는 것을 차단함
- 행 잠금이 너무 잦거나 오래 지속되면, 성능 저하와 병목 현상이 발생할 수 있음
- 이러한 문제를 줄이기 위해서는 트랜잭션을 짧게 유지하고, 가능한 적은 행을 잠그는 방식으로 쿼리를 최적화하는 것이 중요함
##### 데이터 처리량
- 초당 바이트 단위의 데이터 처리량은 다음 2가지 메트릭으로 측정
  - `innodb_data_read`
  - `innodb_data_written`
- 데이터 처리량은 거의 문제가 되지 않음 -> SSD 또는 NVMe로 엄청 빨라짐
- 클라우드와 같은 스토리지 처리량이 제한적이면 모니터링 필요
##### IOPS
- IOPS는 초당 수행되는 입력/출력 작업의 수를 측정하는 지표로, 읽기와 쓰기 2가지 메트릭으로 카운트 됨
  - `innodb.os_data_reads`
  - `innodb.os_data_writes`
- 스터리지 I/O를 최적화 하고 줄이는게 성능 존재 이유 -> IOPS가 적을수록 좋고, 충분히 이용하는게 좋음
- IOPS를 소비하는 3가지 스펙트라
  - 버퍼 풀 효율성
  - 페이지 플러싱
  - 트랜잭션 로그
##### 버퍼 풀 효율성
- 버퍼 풀은 InnoDB에서 메모리 내 데이터와 인덱스를 캐싱하여 디스크 접근을 최소화하는 역할을 함
- 버퍼 풀의 효율성은 시스템 전체 성능에 큰 영향을 미치며, 캐시 히트율을 높여 디스크 I/O를 줄이는 것이 중요함
- 버퍼 풀이 총 데이터 크기 보다 크면 문제가 되지 않지만(전체 데이터를 메모리에 적재), 보통 그렇지 않음
- 버퍼 풀 효율성 세가지 주요 영향
  - 데이터 접근: 데이터를 버퍼풀로 가져옴
  - 페이지 플러싱: 버퍼풀의 데이터를 제거할 수 있음
  - 사용 가능한 메모리: 메모리가 크면 문제가 적음
##### 페이징 플러싱
- 페이징 플러싱은 버퍼 풀에서 변경된 페이지를 디스크에 기록하는 작업으로, 4가지 유형의 페이지가 존재
  - 프리 페이지: 데이터 존재 무, 새로운 데이터 불러올 수 있음
  - 데이터 페이지(클린 페이지): 수정되지 않은 데이터 포함
  - 더티 페이지: 디스크로 플러시되지 않은 수정된 데이터 포함
  - 기타 페이지: 기타 내부 데이터 포함
- InnoDB는 버퍼 풀을 데이터로 가득 채운 상태로 유지하기에 데이터 페이지 수를 모니터링할 필요가 없음
- 페이지 플러싱: 데이터 수정 사항을 디스크에 기록하여 더티 페이지를 정리 -> 지속성, 체크 포인트, 페이지 제거와 밀접
- 페이지 생명 주기
  - 프리 페이지는 데이터가 적재되면 클린 페이지가 됨
  - 클린 페이지는 데이터가 수정되면 더티 페이지가 됨
  - 더티 페이지는 데이터 수정 사항이 플러시되면 다시 클린페이지가 됨
  - 클린 페이지는 버퍼 풀에서 제거되면 다시 프리페이지가 됨
- 2개의 플러싱 알고리즘
  - 적응형 플러싱: 페이지 클리너가 플러시 목록에서 더티 페이지를 풀러시하는 속도를 결정
  - LRU 플러싱: 가장 오래된 페이지를 포함하는 LRU 목록 끝에서 더티페이지를 플러시함
##### 트랜잭션 로그
- 트랜잭션 로그는 트랜잭션이 수행한 변경 사항을 기록하는 로그 파일로, 시스템 충돌 시 데이터를 복구하는 데 중요한 역할을 함
- 페이지가 아닌 데이터 변경 사항(리두 로그)이 포함되지만, 데이터 변경 사항은 버퍼 풀의 더티 페이지에 연결됨
## 6.6 모니터링과 경보
- MySQL 외부에 있으므로 성능에 영향을 미칠 수 없지만, 메트릭과 관련 있으며 MySQL 성공과 밀접함 
##### 레졸루션
- 메트릭이 수집되고 보고되는 빈도를 의미
  - 높을수록 빈도가 높아지며 1초는 30초보다 높음
  - 해상도가 높을수록 더 자세히 관찰 가능<br>
![img_1.png](img_1.png)<br>
![img_2.png](img_2.png)<br>
![img_3.png](img_3.png)
- 최소 5초 이상의 레졸루션으로 KPI를 수집해야함
- MySQL 메트릭은 수집되거나 영구히 사라지므로 될수 있는 한 가장 높은 레졸루션으로 맞추기
##### 헛된 노력(임곗값)
- 임곗값은 합리적이고 좋은 생각인 듯하지만 실제로는 그렇지 않음 -> 특정 부분에 대해 정의가 힘듬
- 임곗값에도 지속 시간(경보가 발생할 때까지 메트릭 값이 임곗값을 지나서 유지되어야 하는 시간)이 필요 -> 지속 시간이 없다면 N번 발생 시, N번 호출(너무 빈번)
- 5초 안에 특정 임계치를 줬는데 경보 발생 -> 이유는 네트워크 블립(일시적) 발생, 입곗값 수정? NO
- 임계값은 완벽하기 어려운 것
##### 사용자 경험과 객관적 한계에 대한 경고
- 임곗값 대신 작동하는 2가지 검증 솔루션
  - 사용자 경험에 대한 경고
  - 객관적 한계에 대한 경고
- 사용자가 경험하는 MySQL 메트릭은 응답시간과 오류 2가지뿐
  - QPS의 변화는 사용자 트래픽에 대한 정당한 변화 <-> 응답 시간의 변화는 응갑 시간의 변화로 설명 가능(오류도 유사)
- MySQL 외부의 일반적인 객관적 한계
  - 사용 가능한 디스크 공간 없음
  - 사용 가능한 메모리 없음
  - 100% CPU 사용률
  - 100% 스토리지 IOPS 사용률
  - 100% 네트워크 사용률
- MySQL이 애플리케이션에 영향을 미치는 일반적인 변수
  - max_connections
  - max_prepared_stmt_count
  - max_allowed_packet
- `AUTO_INCREMENT`열이 최대 값에 근접하고 있는지 확인하는 기본 메트릭이나 방법은 없음 -> 따로 SQL문을 실행하여 메트릭 생성
- QPS와 실행 중인 스레드는 모니터링을 하는 것이 좋지만 경보는 그렇지 않음
  - 응답시간이나 오류로 표시되는 문제를 조사할때 중심이 될수 있지만 신뢰할 수 있는 신호로 쓰기에는 너무 많이 변동됨
- 경고는 DBA가 아닌 MySQL을 사용하는 엔지니어를 위한 알림

##### 원인과 결과
- MySQL의 응답 속도가 느린다면 애플리케이션 원인일 경우가 대부분(약 80%)
  - 실제 MySQL이 느릴확률은 5%에 불과
- 실제 이슈가 생기면 애플리케이션 또는 쿼리 -> 하드웨어 이슈로 생각해보자
  - 위에 추정이 틀리면 치명적인 상황 발생
- 컴퓨터는 유한하고 별개이므로 모든 원인을 알수있지만, 실제로는 모니터링과 로깅이 허용하는만큼의 원인만 확인 가능
  - 해당 예에서 네트워크 이슈로 인해 문제 발생 확인
- MySQL이 느린 이류를 묻는 것보다 근본 원인이나 즉각적인 해결책의 질문은 'MySQL을 느리게 실행되는 원인은 무엇입니까?'