# 2장 주변 친구

## 1단계 : 문제 이해 및 설계 범위 확정
- 기능 요구사항
  - 사용자는 모바일 앱에서 주변 친구(친구와의 거리, 갱신된 시각)를 확인이 가능
  - 몇 초마다 갱신
- 비기능 요구사항
  - 낮은 지연시간(low latency) : 빠른 위치변화 갱신
  - 안정성 : 어느정도의 데이터 유실 용인
  - 결과적 일관성(eventual consistency) : 단기적으로 일관성을 잃더라도 결국에는 일관성을 유지하는 모델
    > [결과적 일관성인가? 최종적 일관성인가?](https://www.popit.kr/%EA%B2%B0%EA%B3%BC%EC%A0%81-%EC%9D%BC%EA%B4%80%EC%84%B1%EC%9D%B8%EA%B0%80-%EC%B5%9C%EC%A2%85%EC%A0%81-%EC%9D%BC%EA%B4%80%EC%84%B1%EC%9D%B8%EA%B0%80/)
- 개략적 규모 추정
  - 1억 DAU
  - 동시 접속 사용자 : 1억 의 10% = 천만
  - 사용자는 30초마다 자기 위치를 시스템에 전송
  - 위치 정보 갱신 QPS = 천만 / 30초 =~ 334,000

## 2단계 : 개략적 설계안 제시 및 동의 구하기
통신 프로토콜을 고민해야 하기 때문에 설계부터 진행
- 개략적 설계안
  - P2P : 일반적인 해결방안이나 모바일이라는 제한적 환경에서는 문제됨(통신 연결상태, 전력 등)
  - 1:N 전파 : 큰 규모시 부하발생
  ```mermaid
  flowchart LR
  A[모바일사용자] --http--> B{로드밸런서}
  A[모바일사용자] <--WebSocket--> B{로드밸런서}
  B <--> C[웹소켓 서버]
  B --> D[API 서버]
  D --> F[사용자 데이터베이스]
  C --> F
  C --> G[위치 이동 이력 데이터베이스]
  C --> H[위치 정보 캐시]
  C --> I[레디스 pub/sub]
  I --> C
  ```
  - 로드밸런서 : RESTful API 및 양방향 유상태 웹소켓 서버 앞단에 위치, 트래픽 배분
  - RESTful API 서버 : 사용자/친구 관리, 인증 및 기타 기능
  - 웹소켓 서버 : 위치 정보 갱신
  - 레디스 위치 정보 캐시 : 가장 최근 위치 정보를 캐시, TTL활용 비활성 상태로 변경
  - 사용자 데이터베이스 : RDBMS, NoSQL 무관
  - 위치 이동 이력 데이터베이스 : 위치변동 이력 보관
    > 친구가 예전에 여기 있었다. 를 구현하려면? 이 데이터로 활용 가능 하겠네
  - 레디스 펍/섭 서버 : 초경량 메시지 버스. 각 사용자별 채널을 구독하며 나의 정보를 발행하거나 친구의 정보를 수신
    > http://redisgate.kr/redis/command/pubsub_intro.php
    >
    > https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-PUBSUB-%EA%B8%B0%EB%8A%A5-%EC%86%8C%EA%B0%9C-%EC%B1%84%ED%8C%85-%EA%B5%AC%EB%8F%85-%EC%95%8C%EB%A6%BC
- API 설계
  - WebSoket
    - 주기적 위치정보 갱신
    - 친구 위치 수신
      > 나-친구 사이의 거리 계산해서 갱신할지 말지 처리?
    - 웹소켓 초기화
    - 친구 구독 및 해지
  - HTTP : 친구 추가/삭제, 사용자 정보 갱신 등
- 데이터 모델
  - 위치 정보 캐시 : 사용자 ID, {위도, 경도, 시각}
  - 위치 이동 이력 데이터베이스
    - 사용자 아이디, 위도, 경도, timestamp
    - 카산드라 : 쓰기 연산 부하, 수평적 규모 확장
    - RDMBS도 무방하나 샤딩이 필요
    > https://goyunji.tistory.com/95
    > 
    > https://db-engines.com/

## 3단계 : 상세 설계
- 중요 구성요소별 규모 확장성
  - API 서버 : 일반적인 방법 (HPA)
  - 웹소켓 서버
    - 기존 노드는 연결종료중(draining) 상태로 변경
    - 모든 연결이 종료 되고나서 서버 제거
    - 추가는 그 반대
  - 클라이언트 초기화
    - 위치정보 캐시에 있는 정보로 사용자의 위치 갱신 (없는 경우 비활성화된 사용자로 인식, TTL)
    - 친구의 정보들을 사용자 데이터베이스에서 조회
    - 거리 계산하여 클라이언트에 반환
    - 친구의 레디스 서버 펍/섭 채널을 구독
    - 현 위치를 레디스 펍/섭 채널을 통해 친구에게 전송
  - 사용자 데이터베이스
    - 사용자의 정보, 친구 관계 데이터
    - 직접 질의하는 대신 해당 API를 통해 데이터 획득
  - 위치 정보 캐시
    - TTL설정
    - 데이터가 많을 경우 사용자 id기준으로 샤딩 : 부하 분산
    - 가용성을 높이기 위해 primary - standby 노드 구성
  - 레디스 펍/섭 서버
    - 위치 변경 내역 메시지의 라우팅 계층으로 활용
    - 모든 사용자마다 채널 하나씩 부여
    - 친구 상태는 미고려, 초경량 메시지 버스의 이점
    - 메모리의 사용량보다 cpu사용량에 병목이 발생할수 있으나 이는 클러스터 구성으로 해결 가능
  - 분산 레디스 펍/섭 서버 클러스터
    - 서비스 탐색(Service Discovery) 컴포넌트의 도입 : 어느 서버로 접근을 해야하는지에 대한 정보. etcd, zookeeper
      > https://bcho.tistory.com/1252
    - 해시링에 의해 분산되는 서버를 결정
      - 메시지를 발행할 펍/섭 서버를 선정하고
      - 위치 정보 변경 내역을 해당 서버(채널)에 발행
    - 규모 확장시
      - 기본적으로 무상태 서버 이지만 어떤 채널이 어느 서버에 있는 이유로 유상태 서버로 봐야 함
      - 클러스터 크기 조정시 엄청난 재구독 요청이 발생할 위험
      - 부하가 낮은 시간에 진행
  - 친구 추가/삭제
    - 각 콜백을 두고 처리, 콜백에서는 구독 또는 구독 취소 기능 실행
    - 해당 콜백을 위치정보 전송 허가/취소 시에도 활용
  - 친구가 많을 경우
    - 핫스팟 문제는 발생하진 않지만 많은 친구들의 채널이 한 클러스터에 모여있을 경우 부하가 갈 수 있음
    - 하지만 문제되는 정도는 아님
  - 주변의 임의 사용자
    - 친구가 아닌 위치 기반으로 임의 사용자를 조회 하는 상황
    - 지오해시 기준으로 레디스 펍/섭 채널을 구성, 구독처리
  - 래디스 펍/섭 외의 대안
    - 얼랭
    - 적은 자원 사용
    - 분산환경에서 장점, 실시간 디버깅, 배포 등 강력함
## 4단계 : 마무리
- 핵심 컴포넌트
  - 웹소켓 : 클라이언트와 서버와의 실시간 통신 지원
  - 레디스 : 캐시
  - 레디스 펍/섭 : 채널을 활용한 라우팅 계층
- 규모 확장
- 임의의 사용자

## 알게 된 키워드
- redis pub/sub, channel
- 카산드라 특징