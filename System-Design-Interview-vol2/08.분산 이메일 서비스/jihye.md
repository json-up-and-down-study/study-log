# 8장. 분산 이메일 서비스

## 1단계: 문제 이해 및 설계범위 확정

- 사용자: 10억명
- 기능
    - ~~인증~~
    - 이메일 발송/수신
    - 모든 이메일 가져오기
    - 읽음 여부에 따른 이메일 필터링
    - 제목, 발신인, 메일 내용에 따른 검색 기능
    - 스펨 및 바이러스 방지 기능
- 메일 서버에 연결하는 방법: HTTP
- 첨부파일도 지원해야 함

### 비기능 요구사항

- 안정성: 메일 데이터는 소실되어서는 안된다
- 가용성
    - 여러 노드에 자동으로 복제
    - 부분 장애가 나도 시스템은 계속 동작
- 확장성: 사용자나 이메일이 많아져도 시스템 성능이 저하되면 안됨
- 유연성과 확장성
    - 새 컴포넌트를 더해 쉽게 기능을 추가, 성능 개선할 수 있는 유연하고 확장성 높은 시스템

### 개략적인 규모 추정

- 사용자 10억명
- 이메일 전송 QPS

  > 10^9(사용자수) * 10 (한 사람이하루에 보내는 평균 이메일 수) / 10^5 = 100_000
>
- 스토리지 요구사항

  > 10억명 * 하루 40건 * 365일 * 50KB(메타 데이터의 평균 사이즈) = 730PB
>
- 1년간 첨부파일을 보관하는데 필요한 저장용량

  > 10억명 * 하루 40건 * 365일 * 20%(첨부 파일을 포함하는 이메일 수) * 500KB(첨부파일 평균 크기) = 1_460PB
>

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 이메일 101

- 이메일을 주고받는 프로토콜
    - SMTP simple mail transfer protocol
        - 이메일을 한 서버에서 다른 서버로 보내는 표준 protocol
    - 이메일 client가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜
        - POP post office protocol
            - 단말로 다운로드 된 이메일은 삭제됨 → 한 대 단말에서만 읽을 수 있다.
            - 이메일을 확인하려면 전부 내려받아야 함 → 용량이 큰 메일은 느림
        - IMAP internet mail access protocol
            - 클릭하지 않으면 다운로드 되지 않고 메일 서버에서 지워지지도 않음 → 여러 단말에서 읽을 수 있음
            - 개인 이메일 계정에서 가장 널리 사용
            - 이메일 열기 전에 해더만 다운로드 → 인터넷 속도가 느려도 잘 동작함
    - HTTPS
        - 메일 전송 프로토콜은 아니지만 웹 기반 이메일 시스템의 메일함 접속에 이용할 수 있음
- DNS domain name service
    - 그림 8.2
    - 우선순위 값 → 숫자가 낮은 값이 우선순위가 높고 연결에 실패하면 그 다음 우선순위를 연결한다
- 첨부파일
    - 일반적으로 Base64 인코딩을 이용
    - MIME multi-purpose Internet Mail Extension
        - 인터넷을 통해 첨부 파일을 전송할 수 있도록 하는 표준 규격
- 전통적 메일 서버
    - 그림 8.3
    - 아웃룩에서 메세지를 작성하고 보내기 버튼을 클릭
    - 이메일은 아웃룩 메일 서버로 SMTP 프로토콜을 이용해 전송 됨
    - 아웃룩 메일 서버는 DNS 질의를 통해 수신 SMTP 서버 주소를 찾고 해당 메일 서버로 SMTP로 이메일을 전송
    - 지메일 서버는 이메일을 저장
    - 유저는 지메일에 로그인 → 지메일 client 는 IMAP/POP 서버를 통해 새 이메일을 가져 온다
- 저장소
    - 전통적인 메일서버는 이메일을 파일 시스템의 디렉토리에 저장
        - Maildir 이름 많이 사용
        - 이메일의 양이 많아지고 파일 구조가 복잡해지면 disk I/O가 병목 → 더 안정적인 분산 데이터 저장소 필요

### 분산 메일 서버

- 이메일 API
    - mail client마다, email 생명 주기 단계마다 달라질 수 있음
    - POST /v1/messages
        - To, Tc, Bcc 헤더에 명시된 수신자에게 메세지를 전송
    - GET /v1/folders
        - 주어진메일 계정에 존재하는 모든 폴더를 반환

            ```json
            id: String, // folder id
            name: String, //folder 이름
            user_id: String // 계정 소유자 id
            ```

    - GET /v1/folders/{:folder_id}/messages
        - 주어진 폴더 아래 모든 메세지 반환, pagination 고려해야 함
    - GET /v1/messages/{:message_id}
        - 주어진 특정 메세지에 대한 모든 정보 반환
        - 발신자, 수신자, 메시지 제목, 본문, 첨부파일 등으로 구성
- 분산메일 서버 아키텍쳐
    - 그림8.5
    - webmail: 웹 브라우저를 통해 메일을 주고 받음
    - webserver
        - user의 request/response 서비스
        - 로그인, 가입, 사용자 프로필 등에 대한 관리 담당
    - 실시간 서버
        - 새로운 메일을 클라이언트에 실시간으로 전달하는 역할
        - 지속성 연결을 맺고 유지
            - stateful server
            - websocket을 쓰고, long-polling을 백업으로
                - ex Apache James → websocket 위에 JMAP(JSON meta application protocol) 구현
    - 메타데이터 DB
        - 이메일 제목, 본문, 발신인, 수신인 목록 등의 메타데이터 저장
    - 첨부 파일 저장소
        - aws S3 simple storage service 객체 저장소 사용
        - 카산드라 같은 column 기반 NoSQL db는 적합하지 않음
            - BLOB binary large object 자료형을 지원하고 최대 크기가 2G 이지만 실질적으로 1MB 이상의 파일을 지원하지 못함
            - 첨부 파일이 많은 메모리를 사용하므로 레코드 캐시를 사용하기 어렵다
    - 분산 캐시
        - 자주 읽을 가능성이 높은 최근 수신한 메일은 메모리에 캐시해두면 메일 표시 시간을 줄일 수 있음
    - 검색 저장소
        - 분산 문서 저장소 distributed document store
        - 고속 텍스트 검색을 지원하는 역인덱스 자료구조로 사용
- 이메일 전송 절차 그림 8.6
    1. 웹 메일 환경에서 메일 전송 → LB → rate limit 체크하여 webserver로 요청 전달
    2. 웹서버
        1. 기본적인 이메일 검증 ( 메일 사이즈 등 )
        2. 수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사
        3. 같다면 바이러스 여부, 스펨 여부 검사
        4. 통과하면 받은 편지함에 저장
        5. 수신측 client는 RESTful API로 이메일을 바로 가져올 수 있고 아래는 수행할 필요 없다
    3. 메세지 큐
        1. 기본적인 검증을 통과한 메일을 MQ에 전달
        2. 첨부파일이 큰 경우 객체 저장소아 저장하고 큐에 전달하는 메일에는 참조 정보를 보관
        3. 검증을 실패한 메일은 에러 MQ에 저장
    4. 외부 전송용 SMTP 서버는 외부 전송용 MQ에서 메세지를 꺼내어 이메일의 스팸, 바이러스 감영 여부 확인 → 통과 후 보낸 편지함에 저장 → 수신자의 메일 서버로 메일 전송
    - 외부 전송용 SMTP 프로세스를 분리함으로써 이 프로세스의 규모를 독립적으로 조정할 수 있게 됨
    - 수신측 메일 서버에 장애가 발생하면 지속적인 backoff 등을 통해 나중에 메일을 다시 전송
- 이메일 수신 절차 그림 8.7
    1. 이메일이 SMTP LB 에 도착
    2. LB는 트래픽을 여러 SMTP로 분산
    3. 첨부파일이 큰 경우 s3에 저장
    4. 이메일을 수신 이메일 큐이 넣어 메일 처리 작업 프로세스와 SMTP 서버간 결합도를 낮춤
        1. 메일처리 작업프로세스는 스팸을 거르고 바이러스를 차단하는 등의 역할을 함
    5. 수신자가 온라인이면 실시간으로 메일을 전송
        1. 웹소켓 서버
    6. 오프라인 상태의 메일은 저장소 계층에 보관했다가 온라인이 되면 웹메일 클라이언트가 웹서버 RESTful API를 통해 연결
    7. 웹 서버는 새로운 이메일을 저장소 계층에서 가져와 클라이언트에 반환

## 3단계: 상세 설계

### 메타데이터 데이터베이스

- 이메일 메타데이터의 특성
    - 헤더가 작고, 빈번하게 이용됨
    - 이메일 본문은 규모가 다양하지만 사용 빈도는 낮다 → 일반적으로 한번만 읽음
    - 이메일 가져오기, 읽은 메일로 표시, 검색 등은 사용자별로 격리 수행해야 한다.
    - 데이터의 신선도는 데이터 사용 패턴에 영향을 끼침 → 최근 메일만 읽는다 (전체 질의의 82%)
    - 데이터 손실은 안됨
- 올바른 데이터베이스의 선정
    - 큰 규모의 메일 서비스는 시스템에 부담이 되기 때문에 보통 초당 입출력 연산 빈도를 낮추기 위해 맞춤 제작 데이터베이스를 사용한다
    - 관계형 데이터베이스
        - 데이터의 크기가 작을 때 적합
        - 비정형 BLOB 자료형 데이터에 대한 검색 질의 성능이 좋지 않다.
            - 해당 컬럼의 데이터에 접근할 때마다 많은 디스크 I/O가 발생
        - PostgreSQL이나 MySQL은 적합하지 않음
    - 분산 객체 저장소
        - s3같은 객체 저장소에 보관 → 읽음 표시, 키워드 검색, 이메일 thread 등의 기능을 구현하기에 그닥
    - NoSQL DB
        - 지메일은 구글 Bigtable을 저장소로 사용하지만 어떻게 구현됐는지 모름
        - 카산드라가 좋은 대안이지만 아직 카산드라를 쓰고 있는 상용 업체는 없음
    - 우리가 원하는 기능을 완벽하게 구현해주는 상용 DB는 없지만 아래의 조건을 충족해야 함을 알고 있어야 함
        - 어떤 단일 컬럼의 크기는 한자릿수 MB 정도일 수 있다
        - 강력한 데이터 일관성 보장
        - 디스크 I/O 최소화 되도록 설계
        - 가용성이 아주 높아야 하고 일부 장애를 감내해야 함
        - 증분 백업이 쉬워야 한다.
- 데이터 모델
    - 파티션 키: 데이터를 여러 노드에 분산하는 구실
    - 클러스터 키: 같은 파티션에 속한 데이터를 정렬하는 구실
    - 특정 사용자의 모든 폴더 질의
        - user_id 를 파티션 키로 잡았기 때문에 모든 폴더는 같은 파티션 안에 있다
    - 특정 폴더에 속한 모든 이메일 표시
        - 가장 최근 이메일부터 정렬 표시해야 하는데
        - 같은 폴더에 속한 모든 이메일이 같은 파티션에 속하려면 user_id, folder_id 를 복합 파티션 키로 이용해야 한다.
        - email_id를 TIMEUUID로 사용하면 정렬에 이용되는 클러스터 키가 된다.
    - 이메일 생성/삭제/수신
        - Select * from emails_by_user where email_id = 123;
    - 읽은 또는 읽지 않은 모든 메일
        - 본 설계안의 DB 는 NoSQL이므로 파티션 키와 클러스터 키에 대한 질의만을 허용
        - is_read 필드는 이에 해당하지 않으므로 아래의 질의문을 실행할 수는 없다

            ```json
            select * from
            email_by_folder
            where user_id = <user_id> and folder_id = <folder_id> and is_read = true
            order by email_id
            ```

            - NoSQL DB 를 비정규화 하여 해결할 수 있다
                - email_by_folder를 read_emails, unread_emails 두 테이블로 분할
    - 이메일 타래 가져오기
        - 전통적으로 타래는 JWZ 같은 알고리즘을 통해 구현 표 8.5
        -