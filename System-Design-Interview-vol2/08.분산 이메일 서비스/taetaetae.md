# 8장 분산 이메일 서비스
- 1단계 : 문제 이해 및 설계 범위 확정
  - 기능 요구사항
    - 10억명 사용자
    - 이메일 발송/수신
    - 이메일 읽기, 읽음 여부에 따른 필터링
    - 검색
    - 스팸처리
    - http로 메일서버 연결
    - 첨부파일 전송 가능
  - 비기능 요구사항
    - 안정성 : 소실되면 안됨
    - 가용성 : 부분 장애시에도 동작 되야함
    - 확장성 : 사용자/이메일이 늘어나도 성능저하 되어선 안됨
    - 유연성과 확장성 : 새로운 기능이 추가될수 있도록
  - 개략적인 규모 추정
    - 이메일 전송 QPS = 10만
    - 한사람당 하루에 평균 40건 수신, 메타데이터 평균 50kb
    - 메타데이터는 데이터베이스에 저장
    - 1년간 메타데이터 = 10억명 x 40건 x 365일 x 50kb = 730PB
    - 첨부파일 포함비율 20%, 평균 500kb
    - 1년간 첨부파일 = 10억명 x 40건 x 365일 x 20% x 500kb = 1,460PB
  - 많은 데이터처리가 필요하기에 분산 데이터베이스 솔루션이 필요

- 2단계 : 개략적 설계안 제시 및 동의 구하기
  - 이메일 프로토콜 : SMTP, POP, IAMP, HTTPS
  - 도메인 이름 서비스 (DNS)
  - 첨부파일 : base64인코딩, 크기제한, 
  - 전통적 메일서버
    - 메일을 전송하면 메일서버에 저장과 동시에 DNS를 거쳐 전송
    - SMTP서버를 이용하여 받으면 저장후 IMAP/POP 서버를 거쳐 사용자가 읽는 방식
    - 파일 시스템의 사용자별 디렉터리에 저장
    - 사용자/메일 양이 많아지며 진화 시작
  - 분산 메일 서버
    - 이메일API (=메일 클라이언트)
      - 쓰기 : POST /v1/message
      - 모든 폴더 조회 : GET /v1/folders
      - 모든 메시지 조회 : GET /v1/folders/{:folder_id}/messages
      - 특정 메시지 조회 : GET /v1/messages/{:message_id}
    - 분산 메일 서버 아키텍처
      - 웹메일 : 브라우저 클라이언트
      - 웹서버 : 사용자가 이용하는 이메일 서비스의 모든 api담당
      - 실시간 서버 : 새로운 이메일 전달, stateful서버, 롱폴링/웹소켓
      - 메타데이터 데이터베이스 : 메타데이터(제목,본문,수신/발신인 등) 저장
      - 첨부파일 저장소 : S3같은 객체 저장소 사용
        - 카산드라 같은 컬럼 기반 NoSql 데이터베이스는 부적합
        - blob 자료형을 지원하지만 레코드 캐시 사용이 어렵고 메모리를 너무 많이 사용할수 있음
      - 분산 캐시 : 최근 수신된 이메일은 레디스 같은곳에 캐시하여 관리
      - 검색 저장소 : 고속 텍스트 검색을 지원하는 역 인덱스를 자료구조로 사용
    - 이메일 전송 절차
      - 웹메일 환경에서 메일 작성 > 로드밸런서에 전달. rate limit 한도 내에서 웹서버로 다시 전달
      - 웹서버
        - 이메일 검증
        - 송/수신 주소, 바이러스, 스팸 등
      - 메시지 큐 : 검증에 성공한 메일은 외부 전송 큐로, 실패한 메일은 에러 큐로
      - 외부 전송 SMTP에서 꺼내어 각종 검사 후 발송
    - 이메일 수신 절차
      - SMTP 로드밸런서에 도착
      - 여러 SMTP서버로 분산
      - 첨부파일 관리 : 너무 큰 경우 파일 저장소에 따로 보관
      - 수신 이메일 큐에 전달, 메일 처리 후 실시간 서버를 통해 사용자에게 웹소켓으로 알림
      - 사용자는 api를 통해 이메일 조회
- 3단계 : 상세 설계
  - 메타데이터 데이터베이스
    - 이메일 메타데이터의 특성
      - 사용자별 격리수행 필요
      - 보통 최근 메일만 읽음
      - 손실 절대 안됨
    - 올바른 데이터베이스의 선정
      - 관계형 데이터베이스 : 데이터가 크고 검색이 어려움
      - 분산 객체 저장소 : S3처럼 보관은 좋으나 주요 기능 구현이 어려움
      - NoSQL : 지메일 사용중
      - 정답은 없지만 아래의 요구사항을 충족해야 함
        - 컬럼의 크기가 작아야 하고 강력한 데이터 일관성 보장
        - 디스크 I/O 최소화, 고가용성, 일부 장애 감내
        - 증분 백업이 쉬어야 함
    - 데이터 모델
      - 파티션 키 : 데이터가 모든 노드에 균등하게 분산
      - 클러스터 키 : 같은 파티션에 속한 데이터를 정렬
      - 질의별 키 타입
        - 특정 사용자의 모든 폴더 질의 : 파티션 키 = user_id
        - 특정 폴더에 속한 모든 이메일 표시 : user_id + folder_id 복합 파티션 키, email_id로 정렬(TIMEUUID)
        - 이메일 생성/삭제/수신 : email_id 와 filename필드로 질의
        - 읽은/읽지 않은 모은 메일
          - 간단히 is_read라는 컬럼으로 처리할수 있지만 NoSQL이라 파티션/클러스터 키에 대한 질의만 허용
          - 비정규화를 통해 읽은/읽지 않은 이메일을 미리 구분하여 처리
        - 이메일 타래(threads)가져오기 : 메세지 식별자, 어떤 답신인지 나타내는 식별자, 메시지 식별자 목록을 활용하여 타래를 가져올 수 있음
      - 데이터 일관성을 위해 가용성을 희생
  - 전송 가능성
    - 스팸으로 결정되지 않기 위한 다양한 노력들
  - 검색
    - es
      - 이메일 전송/수신/삭제 는 카프카를 통한 비동기식 호출로 처리
      - 검색은 es를 활용하여 동기식 호출
    - 맞춤형 검색 솔루션
      - LSM(Long Structured Merge) 트리 활용
      - 디스크에 저장되는 색인을 구조화
  - 규모 확장성
    - 가용성 확장을 위한 여러 데이터 센터에 다중화
- 4단계 : 마무리
  - 추가 논의
    - 결함 내성
    - 규정 준수
    - 보안
    - 최적화
