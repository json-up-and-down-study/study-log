# 12장. 전자지갑

## 1단계 : 문제 이해 및 설계 범위 확정

- 요구 사항
    - 전자 지갑간 이체
    - 1,000,000 TPS
    - 99.99%의 안정성
    - 트랜잭션
    - 재현성
- 개략적 추정
    - 출금 뒤에 입금 연산 = 2배 = 2백만 TPS
    - 단일 노드가 처리할 수 있는 트랜잭션 수를 늘리는 것에 중점

## 2단계 : 개략적 설계안 제시 및 동의 구하기

- API설계
    - POST /v1/wallet/ballance_transfer
    - body : 인출/이체 계좌, 금액, 통화단위, 중복 제거id
- 인모메리 샤딩
    - 원자적 트랜잭션으로 실행 되어야 함
    - 레디스 노드가 다른 상황에서의 트랜잭션 문제
- 분산 트랜잭션
    - 데이터베이스 샤딩 : 데이터베이스가 물리적으로 다르면 보장이 안됨
    - 분산트랜잭션 : 2단계 커밋
        - 첫번째 커밋에서 락을 활용 후 트랜잭션 보장
        - 락이 오래 걸리는 경우 성능이 안좋음 (SPOF 유발)
    - 분산 트랜잭션 : TC/C
        - 시도-확정/취소
        - 분산트랜잭션은 하나의 트랜잭션이지만 TC/C는 각 단계가 별도 트랜잭션
        - 비교
            - 데이터베이스에 구애받지 않는 TC/C
            - 어플리케이션에서 트랜잭션 복잡성을 처리해야 함
        - 단계별 상태 테이블
            - TC/C 실행 도중 서비스가 다시 시작되면 복구가 어려움
            - 이를 방지하기 위해 각 트랜잭션 데이터베이스에 상태 정보를 저장
        - 불균형 상태
            - TC/C : 실행주체는 어플리케이션이며 독립적 로컬 트랜잭션이 만드는 중간 결과를 볼 수 음
            - 2PC : 실행 주체는 데이터베이스, 어플리케이션은 중간 실행 결과를 알 수 없음
    - 분산 트랜잭션 : 사가
        - 모든 연산은 순서대로 정렬, 각 연산은 자기 데이터베이스에 독립 트랜잭션으로 실행
        - 연산이 실패하면 전체 프로세스는 실패한 연산부터 맨 처음 연산까지 역순으로 보상 트랜잭션을 통해 롤백
        - 연산 실행 순서
            - 분산조율
            - 중앙 집중형 조율 : 복잡한 상황을 잘 처리하기 때문에 선호
- 이벤트 소싱
    - 정의
        - 명령 : 의도가 명확한 요청, 순서 중요
        - 이벤트 : 검증된 사실, 과거 시제 사용
        - 상태 : 이벤트가 적용될 때 변경되는 내용
        - 상태 기계 : 이벤트 소싱 프로세스를 구동 (명령의 유효성 검사, 이벤트를 적용하여 상태를 갱신)
    - 재현성
        - 이벤트를 처음부터 다시 재생하면 과거 잔액 상태는 언제든 재구성이 가능
    - 명령-질의 책임 분리 (CQRS)
        - 이벤트를 수신하는 외부 주체가 직접 상태를 재구축할 수 있다.
        - 상태 기록을 담당하는 상태기계는 하나, 읽기 전용 상태 기계는 여러개
        - 읽기 전용 상태 기계는 실제 상태에 어느정도 뒤쳐질 수 있으나 결국에는 같아짐. 따라서 결과적 일관성 모델을 따른다 할 수 있다.

## 3단계 : 상세 설계

- 이벤트 소싱 아키텍처는 하나의 이벤트만 처리하는데다 여러 외부 시스템과 통신해야 함으로 속도가 느리다.
- 고성능 이벤트 소싱
    - 파일기반으로 구성
    - mmap 을 사용하면 로커러 디스크에 쓰는 동시에 최근 데이터는 메모리에 자동으로 캐시 가능
    - 일반적으로 순차적 쓰기 연산은 매우 빠르다.
    - 스냅샷을 활용하여 재현 프로세스의 속도를 높임. 일반적으로 이진파일이며 HDFS과 같은 객체 저장소에 저장
- 무상태 서버가 아닌데다 단일 장애 지점이 된다는 문제. 안정성을 올리기 위한 방안
    - 신뢰성을 올리기 위해 래프트 알고리즘 활용 (리더/후보/팔로어)
    - 여러 노드에 이벤트 목록을 복제하고 명령 수신과 복제는 리더가 담당
- 시스템의 확장성을 올리기 위한 방안
    - 분산 이벤트 소싱
        - 풀 : 실시간이 아니며 너무 짧게 설정함현 과부하
        - 역방향 프락시를 추가하여 푸시 이벤트를 받음 (이벤트의 최신 상태를 실시간으로 푸시)

## 4단계 : 정리

- 레디스 같은 인메모리 키-값 저장소 사용
    - 데이터의 내구성이 없음
- 인메모리 캐시 → 트랜잭션 데이터 베이스로 변경, 분산 트랜잭션 프로토콜 활용
    - 데이터 감사가 어려움
- 이벤트 소싱
    - 외부 데이터베이스와 큐 활용 : 성능이 좋지 않음
    - 로컬 파일 시스템에 저장하여 성능을 개선
        - SPOF 문제
        - 안정성을 높이기 위해 이벤트 목록을 여러 노드에 복제
- 이벤트 소싱 + CQRS + 비동기 이벤트 소싱 프레임워크를 동기식으로 변경 (+역방향 프락시)
    - 앞단에 분산 트랜잭션 프로토콜 활용
